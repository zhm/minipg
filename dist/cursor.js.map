{"version":3,"sources":["../src/cursor.js"],"names":["Cursor","client","batchOffset","batchStart","batch","index","columns","finished","needsMetadata","callback","next","err","values","done","each","nextBatch","length","eachBatch","error","_index","processResult","row","process","nextTick","getResults","results","nativeClient","hasResult","hasColumns","emptyResultSet","endOfResultSet","lastError"],"mappings":"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","sourcesContent":["export default class Cursor {\n  constructor(client) {\n    this.client = client;\n    this.batchOffset = 0;\n    this.batchStart = 0;\n    this.batch = [];\n    this.index = 0;\n    this.columns = null;\n    this.finished = false;\n    this.needsMetadata = true;\n  }\n\n  each(callback) {\n    this.next((err, {finished, columns, values, index, client}) => {\n      const done = () => {\n        if (!finished) {\n          this.each(callback);\n        }\n      };\n\n      callback(err, {finished, columns, values, index, client, done});\n    });\n  }\n\n  eachBatch(callback) {\n    this.nextBatch(() => {\n      const done = () => {\n        this.index += this.batch.length;\n\n        if (!this.finished) {\n          this.eachBatch(callback);\n        }\n      };\n\n      /* eslint-disable callback-return */\n      callback(this.error,\n               {finished: this.finished,\n                columns: this.columns,\n                values: this.batch,\n                index: this.index,\n                client: this.client,\n                done});\n      /* eslint-enable callback-return */\n    });\n  }\n\n  next(callback) {\n    this._index = this._index != null ? this._index : 0;\n\n    const processResult = () => {\n      let values = null;\n\n      if (this.batch.length) {\n        const row = this.batch[this.batchOffset];\n\n        this.batchOffset += 1;\n\n        values = row ? row.values : null;\n      }\n\n      /* eslint-disable callback-return */\n      callback(this.error,\n               {finished: this.finished && this.batchOffset === this.batch.length,\n                columns: this.columns,\n                values: values,\n                index: this._index,\n                client: this.client});\n\n      this._index++;\n      /* eslint-enable callback-return */\n    };\n\n    if (this.batchOffset < this.batch.length) {\n      if (this.batchOffset % 1000 === 0) {\n        process.nextTick(processResult);\n      } else {\n        processResult();\n      }\n    } else {\n      // we need to fetch the next batch into memory\n      this.nextBatch(processResult);\n    }\n  }\n\n  nextBatch(callback) {\n    if (this.needsMetadata) {\n      this.index = 0;\n      this.columns = null;\n    }\n\n    this.client.getResults(this.needsMetadata, (results) => {\n      this.needsMetadata = false;\n      this.batch = results;\n      this.batchOffset = 0;\n      this.finished = this.client.nativeClient.finished();\n\n      const hasResult = results && results.length;\n\n      const hasColumns = hasResult && results[0] && results[0].columns;\n\n      // results == [ null ]\n      const emptyResultSet = hasResult &&\n                             results[results.length - 1] == null;\n\n      // results == [ ..., {} ]\n      const endOfResultSet = hasResult &&\n                             results[results.length - 1] &&\n                             results[results.length - 1].values == null;\n\n      if (hasColumns) {\n        this.batchStart = 0;\n        this.columns = results[0].columns;\n      }\n\n      // There are several possible states here because the client supports\n      // multiple result sets in a single query and the complexity that batching adds.\n      //\n      // finished?               -> we are done, don't do anything\n      // results === []          -> it's the signal of finished result set\n      // results === [ null ]    -> a query that had no result set all (no column def, just a command like CREATE TABLE)\n      // results === [ ..., {} ] -> the end of a result set has a {} at the end, note that this is NOT the end\n      //                            of the entire cursor stream because there might be more SELECT queries in the command\n      //                            text. If there are, this section below resets the index and the metadata flag so\n      //                            that the next call to getResults will request the column metadata of the next query.\n      //                            This is important when, for example, there are 2 completely different SELECT statements\n      //                            in the command text. In that case we need to ask for metadata twice.\n      if (!this.finished && (emptyResultSet || endOfResultSet)) {\n        this.needsMetadata = true;\n      }\n\n      const error = this.client.lastError;\n\n      if (error) {\n        this.error = error;\n      }\n\n      /* eslint-disable callback-return */\n      callback();\n      /* eslint-enable callback-return */\n\n      if (results) {\n        this.batchStart += results.length;\n      }\n\n      if (endOfResultSet) {\n        this.batchStart = 0;\n      }\n    });\n  }\n}\n"],"file":"cursor.js"}